## 浮点数精度问题

```javascript
console.log(0.1+0.2);

// 0.30000000000000004
```

浮点数精度问题导致,并非 ECMAScript 这门语言导致

## 数字类型

ECMAScript中的Number类型使用 IEEE754标准来表示整数和浮点数值

IEEE754 (IEEE二进制浮点数算数标准)

在IEEE754中规定了四种表示浮点数值的方式

1. 单精确度(32位)
2. 双精确度(64位)
3. 延伸单精确度
4. 延伸双精确度

>ECMAScript采用的是双精确度,用64位字节来储存一个浮点数

## 浮点数的存储

虽然0.1转成二进制是一个无限循环的数,但是计算总要存储,ECMAScript使用64位字节存储一个浮点数

这个标准认为一个浮点数(Value)这样表示

> Value = sign * exponent * fraction

简单理解就是科学计数法

比如 -1020 用科学计数法表示:

> -1 * 10^3 * 1.02

sign就是 -1, exponent就是 10^3, fraction就是 1.02

因为两次存储的精度丢失机上一次运算时的精度丢失,最终导致0.1+0.2 !== 0.3

## 其他

```javascript
// 十进制转二进制
parseFloat(0.1).toString(2);
=> "0.0001100110011001100110011001100110011001100110011001101"

// 二进制转十进制
parseInt(1100100,2)
=> 100

// 以指定的精度返回该数值对象的字符串表示
(0.1 + 0.2).toPrecision(21)
=> "0.300000000000000044409"
(0.3).toPrecision(21)
=> "0.299999999999999988898"
```