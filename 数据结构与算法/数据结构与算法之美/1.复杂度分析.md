## 什么是复杂度分析?

### 1. 数据结构和算法解决的是 "如何让计算机更快更省空间的解决问题"
### 2. 需要从执行时间和占用空间两个维度来评估数据结构和算法的性能
### 3. 分别用时间复杂度和空间复杂度两个概念来描述性能问题,二者统称复杂度
### 4. 复杂度描述的是算法执行时间或占用空间与数据规模的增长关系
   
## 为什么要进行复杂度分析?

### 1. 和性能测试相比,复杂度分析不依赖执行环境,成本低,效率高,易操作,指导性强的特点
### 2. 掌握复杂度分析,可以编写出性能更优的代码,有利于降低开发和维护的成本
   
## 大O表示法

### 所有的代码执行时间T(n)与每行代码的执行次数成正比

```txt
T(n) = O(f(n))
T(n)表示代码执行的时间
n表示数据规模的大小
f(n)表示每行代码执行的次数总和
O表示代码的执行时间T(n)与f(n)表达式成正比
```

### 大O表示代码执行时间随数据规模增长的变化趋势，也叫作时间复杂度

## 时间复杂度分析

### 只关注执行最多的一段代码
  
### 我们分析一个算法，一段代码的复杂度时，只关注循环执行次数最多的一段代码就行了

## 加法法则
  
### 一段代码中有单循环和多重循环,那么取多重循环的复杂度

## 乘法法则
  
### 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

## 复杂度量级

## 多项式阶

### 随着数据规模的增长,算法的执行时间和空间占用,按照多项式的比例增长,包括,O(1)（常数阶）,O(logn)（对数阶）,O(n)（线性阶）,O(nlogn)（线性对数阶）,O(n^2)（平方阶）,O(n^3)（立方阶）

### 非多项式量级

### 1. 指数阶O(2^n)
### 2. 阶乘阶O(n!)
   
### 复杂度为非多项式量级的算法问题叫做NP问题,当数据规模n越来越大时,算法的执行时间和空间占用暴增,这类算法的性能极差

### 常见的多项式时间复杂度

## 1. O(1)
   
```javascript
let i = 8;
let j = 6;
let sum = i + j;
// O(1)只是常量级复杂度的一种表示方法,并不是指只执行了一行代码,比如这段代码只执行了3行,它的复杂度也是O(1),而不是0(3)
```

>总结: 一般情况下只要代码不存在循环语句,递归语句,即便成千上万行代码,时间复杂度也是O(1)

## 2. O(logn),O(nlogn)
	
```javascript
i = 1;
while(i <= n){
	i = i * 2;
}
// 第三行代码执行最多次,计算出这行代码执行了多少次,就知道整段代码的时间复杂度
// 变量i从1开始取,每循环一次就乘以2,当于n时循环结束,实际上变量i的取值就是一个等比数列,如果一个个列出来
// 2^0 ... 2^1 ... 2^2 ... 2^k ... 2^x = n
// 通过2^x=n求解 x=log2n
// 所以这段代码的时间复杂度为 O(log2n)
```

## 把代码稍微改动下

```javascript
i = 1;
while(i <= n){
	i = i * 3;
}
// 根据刚才的思路很简单就可以看出这段代码的时间复杂度为O(log3n)
```

>总结: 对数之间是可以相互转化的,采用大O标记复杂度的时候,可以忽略系数,即 O(Cf(n) = Of(n)),所以在对数阶时间复杂度的表示方法里,我们忽略对数的底,统一表示为O(logn)

### 如果一段代码的时间复杂度为O(logn),那么将它执行n遍就是O(nlogn)

### O(nlogn)非常的常见,比如 归并排序,快速排序

## 3. O(m+n),O(m*n)
   
### 代码的复杂度由两个数据来决定

```javascript
function cal (m,n) {
	let sum_1 = 0;
	for(let i=0; i<m; i++){
	sum_1 += i;
}

let sum_2 = 0;
for(let j=0; j<n; j++){
	sum_2 += j;
}

return sum_1 + sum_2;
}
// m,n 表示两个数据规模,我们无法评估m和n谁的量级大,所以在表示复杂度的时候就不能用加法法则省略其中一个了,所以上面的代码时间复杂度就是O(m+n)
```

>总结: 针对这样的情况,原来的加法法则就不正确了,我们将加法规则改为: T1(m) + T2(n) = O(f(m) + g(n)),但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))

## 空间复杂度分析

### 时间复杂度全称是渐进时间复杂度,表示算法的执行时间与数据规模之间的增长关系

### 类比一下,空间复杂度全称是渐进空间复杂度,表示算法的存储空间与数据规模之间的增长关系

## 复杂度分析的4个概念
### 1. 最坏情况时间复杂度: 代码在最坏情况下执行的时间复杂度
### 2. 最好情况时间复杂度: 代码在最理想情况下执行时间复杂度
### 3. 平均时间复杂度: 代码在所有情况下执行的次数的加权平均值
### 4. 均摊时间复杂度: 在代码执行的所有复杂度情况大部分是低级别复杂度,个别情况是高级别复杂度且发生具有时序关系时,可以将个别高级别复杂度均摊在低级别复杂度上,基本上均摊结果等于低级别复杂度

## 如何分析平均或均摊时间复杂度?

## 平均时间复杂度

### 代码在不同情况下复杂度出现量级差别,则用代码所有可能情况下执行次数的加权平均值表示

## 均摊时间复杂度

### 代码绝大多数情况下都是低级别复杂度,只有极少数情况是高级别复杂度

### 低级别和高级别复杂度出现具有时序规律,均摊结果一般都地狱低级别复杂度

