# Node简介

## Node的特点

+ 异步I/O: 在Node中绝大多数的操作都是以异步的方式进行调用
+ 事件与回调函数: Node除了异步和事件外,回调函数是一大特色,纵观下来,回调函数也是最好的接受异步调用返回数据的方式
+ 单线程: Node保持了javascript在浏览器中单线程的特点,单线程最大的好处是不用像多线程那样处处在意状态的同步问题
  + 单线程的缺点
  + 无法利用多核CPU
  + 错误会引起整个应用退出
  + 大量计算占用CPU导致无法继续调用异步I/O
+ 跨平台

## Node的应用场景

+ I/O 密集型: 优势主要在于Node利用时间循环的处理能力,而不是启动每一个线程为每一个请求服务,资源占用极少
+ 是否不擅长CPU密集型服务: CPU密集不可怕,如何合理调度是诀窍
+ 分布式应用

# 模块机制

## CommonJS规范

CommonJS规范为javascript制定了一个美好的愿景,希望javascript能够在任何地方运行

## CommonJS的模块规范

1. 模块引用

reuqire()方法,引入一个模块API到当前上下文中

2. 模块定义

上下文提供了export对象用于导出当前模块的方法或者变量,并且它是唯一导出的出口

在模块中还存在一个module对象,它代表模块本身,而exports是module的属性

3. 模块标识

模块标识其实就是传递给require()方法的参数,它必须符合小驼峰命名的字符串,它可以没有文件名后缀

## Node的模块实现

在Node引入模块,需要经历三个步骤:

1. 路径分析
2. 文件定位
3. 编译执行

在Node中模块分为两类: 一类是Node提供的模块,成为核心模块,另一类是用户编写的,成为文件模块

+ 核心模块: 在Node源代码的编译过程,编译进了二进制执行文件,在Node进程启动时,部分核心模块就被直接加载进内存中,所以核心模块引入时,文件定位和编译执行可以省略掉,并且路径分析中优先判断,所以它的加载速度最快
+ 文件模块: 运行时动态加载,需要完整的路径分析、文件定位、编译执行过程,速度比核心模块慢

### 优先从缓存加载

Node引入过的模块都会进行缓存,缓存的是编译和执行之后的对象,以减少二次引入时的开销

不论是核心模块还是文件模块,require方法对相同模块的二次加载一律采用缓存优先, **核心模块的缓存检查先于文件模块的缓存检查**

### 路径分析和文件定位

1. 模块标识符分析

模块路径的生成规则

+ 当前文件目录下的 node_modules目录
+ 父目录下的 node_modules目录
+ 父目录的父目录下的 node_modules目录
+ 沿路径向上递归,直到根目录下的 node_modules目录

与javascript的原型链或作用域链的查找方式类似,Node会逐个尝试模块路径中的路径,直到找到目标文件为止,当前文件的路径越深,模块查找耗时越久,这就是自定义模块加载速度慢的原因

2. 文件定位

+ 文件拓展名: 标识符不包含文件扩展名情况下,Node会按 js、json、node次序补足扩展名,依次尝试
+ 目录分析和包: 分析标识符过程中,require通过分析文件扩展名后可能没有找到对应文件,但是得到一个目录,此时Node会将目录当做一个包来处理,Node会在当前目录下寻找package.json,如果不存在,Node会将index当做默认文件名,如果在目录分析没有定位成功任何文件则自定义模块进入下一模块路径查找

### 模块编译

对于不同的文件扩展名,载入方法也不同

+ js文件: 通过fs模块同步读取文件后编译执行
+ node文件: 这是用C/C++ 编写的扩展文件,通过dlopen()方法加载最后编译生成的文件
+ json文件: 通过fs模块读取文件后,通过JSON.parse()解析返回结果
+ 其余扩展名文件: 都被当做js文件载入

每个编译成功的模块都会将其文件路径作为索引缓存在 Module._cache对象性上,提高二次引入的性能