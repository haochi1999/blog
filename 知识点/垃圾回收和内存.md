# V8如何进行垃圾回收

js引擎中对变量的存储有两个位置,栈内存和堆内存

+ 栈内存: 存储基本类型数据以及引用类型数据的内存地址
+ 堆内存: 存储引用类型的数据

## V8垃圾回收策略

v8采用一种代回收的策略,将内存分为两个生代,新生代和老生代

新生代的对象为存活时间较短的对象老生代的对象为存活时间较长或常驻内存的对象,分别对象新老生代采用不同的垃圾回收算法来提高效率,对象一开始会被分配到新生代(如果新生代内存不够,直接分配到老生代),新生代的对象会在满足某种条件后,被移到老生代,这过程也叫晋升

### 分代内存

+ 32位系统: 新生代16MB 老生代 700MB
+ 64位系统: 新生代32MB 老生代 1.4GB

新生代平均分成两块相等的内存空间,叫做 semispace

### 新生代

1. 分配方式

新生代存的都是生命周期短的对象,分配内存也很容易,只保存一个指向内存空间的指针,根据分配对象的大小递增指针就可以了,当内存快满时,就进行一次垃圾回收

2. 算法

使用 Scavenge 进行管理,主要采用 Cheney 算法,将内存一分为二,一块处于使用状态,一块处于闲置状态

使用状态的称为 From空间,处于闲置状态的称为 To空间

From和To交换,就是为了让活跃对象始终保持在一块内存中,另一块内存始终保持空闲状态

3. 晋升

当一个对象经过多次复制仍然存活,它就会被认为是生命周期较长的对象,这种较长生命周期的对象随后会被移到老生代中,采用新的算法管理

如果一个对象是第二次经历从From空间复制到To空间,那么这个对象会被晋升

### 老生代

在老生代中存活对象占较大的比重,如果继续采用 Scavenge算法进行管理,就会存在两个问题:

存活对象较多,复制存活对象的效率很低

采用 Scavenge算法会浪费一半内存,由于老生代所占堆内存远大于新生代,所以浪费更加严重

1. Mark-Sweep(标记清除)

Mark-Sweep在标记阶段遍历堆内存中所有对象,并标记活着的对象,在随后的清除阶段,只清除没有标记的对象

也就是说 Scavenge 只复制活着的对象,而 Mark-Sweep只标记死了的对象,活对象在新生代中占较少部分,死对象在老生代中占较少部分,这就是两种回收方式都能高效处理的原因

问题: 在进行一次清除回收以后,内存空间会出现不连续的状态,这种内存碎片会对后续内存的分配造成问题

2. Mark-Compact

Mark-Compact标记完存活对象以后,会将活着的对象向内存空间的一端移动,移动完成后,直接清理掉边界外的所有内存

### 两者结合

V8的回收策略中 Mark-Sweep 和 Mark-Compact结合使用

Mark-Compact需要移动对象,所以它的执行速度不可能快,在取舍上V8主要使用 Mark-Sweep ,在内存不足以对新生代晋升过来的对象进行分配时,才使用 Mark-Compact

